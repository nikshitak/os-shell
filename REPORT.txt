- Describe how you keep track of open file offsets
I created an ActualFile class that implements the File class that holds a Shared<Node> 
(that holds a file) and the offset. In seek(), I set the file offset equal
to the value passed in throuh seek() so that the ActualFile keeps trace of the 
absolute offset.  

- Explain why it's a good idea to copy the exec args in kernel space
  before performing the exec
Copying the exec args in kernel space before calling exec is a good idea because 
we want to prevent the user from accessing/modifying any data in the kernel
space. Copying the arguments into the kernel space allows the program
to still have access to these arguments when it switches to user mode. 
Also, the kernel has the power to validate these arguments before passing them
onto any other function calls, so coping the exec args into the kernel space is 
a good idea. 

- List 3 security exposures that your implementation of exec addressed
1. I make sure that the ELF Header contains all the valid magic numbers
so that the process knows where to start running the program and that
it is *able* to run the program (by checking for endianness because this is a 
basic implementation of the ELF file and by checking if the ELF Header
had a valid version and if it's created for a 64 or 32 bit machine).

2. User cannot access data in kernel data because the user is not 
*supposed* to access the data in the kernel. That is data that the kernel
needs to run, and stopping the user from being able to access/modify that data 
means that the kernel can keep those arguments passed into exec() untouched. 

3. By clearning the private address space, we remove any leftover data or code from 
the previous execution context, preventing potential information leaks from the 
previous execution.

- Read about the opendir system call. Why do we need a dedicated system
  call for opening directories? Why not just open a directory as if it
  were a file and look at its internal representation?
A directory has a lot more metadata in terms of what type of files it holds and
also has to have a way to describe the internal representation of the directory. 
There are also certain directory methods (looking for entries, handling
symlinks) that are just better off implemented with a different system call rather
than dealing with it as a file.

- We implement the open, close, read, and write system calls. All
  Unix-like systems have corresponding higher level library
  functions: fopen, fclose, fread, and fwrite. How come?
These higher level library functions make it a lot easier to override
for different types of systems as these functions will need to be optimized
for the differnet systems that they're implemented for. In our case, open, close,
read, and write are all optimized for our basic EXT2 and file directory implementation,
while other systems would want a different optimization.

- Why does my implementation of SYS::exec set file to nullptr?
After exec runs ELF::load(), we do not want to be able to access the
file at that point because any relevant information in terms of the
ELF and file directory is already loaded in the kernel and the user
doesn't have any more need to that file variable, so it's just safer 
to set that to nullptr.
